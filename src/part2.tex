%\section{новые возможности электронного задачника по программированию}
% \subsection{Новый вариант конструктора TaskMake и созданная на его основе динамическая библиотека (язык Free Pascal Lazarus)}
% \subsubsection{Реализация нового варианта конструктора учебных заданий TaskMaker}
% В качестве такого механизма можно использовать тот же механизм, который лежит в основе архитектуры самих задачников, а именно — динамические библиотеки. Исходный код учебных заданий, разработанный для Delphi Pascal, может компилироваться в среде Free Pascal Lazarus, которая позволяет разрабатывать программы для различных платформ (заменим, что именно в этой среде реализована новая версия ядра задачника Programming Taskbook для 32- и 64-разрядных сред программирования). Таким образом, достаточно, не переписывая исходный код учебных заданий, откомпилировать его в варианте Free Pascal Lazarus для Linux, чтобы получить динамическую библиотеку, доступную для использования в задачнике Unix Taskbook. 
% Разумеется, для возможности получения такой библиотеки необходимо разработать новый вариант конструктора TaskMaker, который должен содержать тот же набор функций, что и исходный конструктор, однако взаимодействовать эти функции должны не с ядром задачника Programming Taskbook, а с задачником Unix Taskbook. Так как интерфейс, по которому задачник Unix Taskbook взаимодействует с подключаемыми динамическими библиотеками, существенно отличается от аналогичного интерфейса, используемого задачником Programming Taskbook, удобно ввести «промежуточное звено» между динамической библиотекой, содержащей задачи из задачника Programming Taskbook, и задачником Unix Taskbook. Таким промежуточным звеном является обычный текстовый файл, который генерируется исходной динамической библиотекой и содержит полную информацию о выполняемом задании. Таким образом, адаптация конструктора TaskMaker сводится к тому, чтобы вместо пересылки всех необходимых данных ядру задачника Programming Taskbook выполнять их сохранение в файле в определенном формате. Такая адаптация не требует учета особенностей задачника Unix Taskbook и поэтому может быть легко реализована и надежно протестирована.
% Примечание. Наличие полной информации о выполняемом задании (включающей и пример правильного решения) может приводить к возможности «злоупотреблений» со стороны учебной программы, которая вместо «настоящего» решения задачи может просто попытаться «украсть» необходимые данные из соответствующего текстового файла. Однако это не является принципиальной проблемой, поскольку динамическая библиотека для задачника Unix Taskbook может быть организована таким образом, чтобы считывать все необходимые данные из файла и удалять этот файл еще до запуска учебной программы с решением задачи.
% Итак, первым этапом в реализации программы переноса набора учебных заданий из задачника Programming Taskbook в задачник Unix Taskbook, является разработка нового варианта конструктора учебных заданий (на языке Pascal), который позволял бы без каких-либо модификаций исходного кода, связанного с генерацией учебных заданий, сохранять всю необходимую информацию в некотором файле на диске. 
% Этот этап успешно реализован. Разработан модуль PT43Make, который содержит большинство функций, обеспечивающих инициализацию заданий (за исключением функций, позволяющих добавлять в задание «внешние» данные — файлы и динамические структуры). Все данные, связанные с созданным заданием, сохраняются в текстовом файле определенного формата с фиксированным именем \$\$pt4dat\$\$.dat.
% Из числа особенностей реализации модуля PT43Make можно отметить следующие.
% Информация о каждом элементе исходных или контрольных данных сохраняется в записи типа TData, которая включает поля id (символ-идентификатор, определяющий тип элемента — b, i, r, c, s), n (значение числового элемента; используется для типов b, i, r), s (значение текстового элемента; используется для типов c и s), x, y, w, p, r (дополнительные поля, определяющие способ отображения элемента на экране: x, y — координаты начальной позиции, w — ширина поля вывода, p — точность для вещественных чисел, r — ранг процесса, в котором используется данный элемент, для задач по параллельному MPI-программированию).
% Информация о формулировке задания и дополнительных комментариях, которые могут быть связаны с некоторыми элементами исходных и контрольных данных, сохраняется в записи типа TComment с полями s (текст строки формулировки или комментария), x, y (координаты начальной позиции).
% Как и для задачника Programming Taskbook, допускается использовать до 200 исходных и контрольных данных и до 205 строк, связанных с формулировкой задания и комментариями к исходным и контрольным данным. Для хранения этих данных определены типы 

% \lstset{language=pascal}
% \begin{lstlisting}
% TDataArray = array[0..200] of TData;
% TCommentArray = array[0..205] of TComment;  
% \end{lstlisting}

% Информация об исходных и контрольных данных хранится в массивах idata, odata типа TDataArray, информация о комментариях и формулировке задания хранится в массивах icmt, ocmt, ttext типа TCommentArray.
% Для заполнения данных массивов предусмотрены функции AddIData, AddOData, AddICmt, AddOCmt, taskText. Все функции конструктора TaskMaker, связанные с определением данных и комментариев, реализованы с применением этих вспомогательных функций, например:

% \lstset{language=pascal}
% \begin{lstlisting}
% procedure dataN(cmt: string; a: integer; x,y,w: integer);
% var w1: integer;
% begin
%     w1 := AddICmt(cmt, x, y, w);
%     AddIData('i', a, '', w1 + PosX(x, w1 + w), y, w);
% end;
% \end{lstlisting}

% Функции, определяющие дополнительные настройки задания, просто сохраняют эти настройки в специальных переменных, например:

% \lstset{language=pascal}
% \begin{lstlisting}
% procedure SetNumberOfTests(n: integer);
% begin
%     NumberOfTests := n;
% end;
% \end{lstlisting}

% В модуль входит специальная функция CorrectY, позволяющая определить фактическое количество строк, используемых для отображения формулировки задания, исходных и контрольных данных (в ней удаляются строки, не содержащие данных, и выполняется пересчет номеров оставшихся строк). Необходимость в такой функции связана с тем, что в ранних версиях задачника Programming Taskbook (для которых и было реализовано большинство базовых заданий) для каждого раздела выделялось по 5 строк, и некоторые строки могли оставаться пустыми.
% Потребовалось также откорректировать функцию, связанную с обработкой управляющих последовательностей, которые могут использоваться в формулировке задания и комментариях. Эта функция имеет имя realComment; ввиду ее большого размера она реализована во вспомогательном модуле UComments. В текущей версии конструктора управляющие последовательности, связанные с форматированием, просто игнорируются, а вместо специальных символов (например, $\leq$) используются комбинации символов ASCII (например, <=). В дальнейшем функция realComments может быть модифицирована, чтобы обеспечить дополнительные возможности по форматированию текста формулировки и комментариев и по отображению специальных символов.
% Итоговые действия по сохранению всех данных, связанных с заданием, выполняются в функции Pause, которая должна вызываться в конце набора функций, определяющих каждое задание.

% \subsubsection{Применение нового варианта конструктора для получения динамической библиотеки с группами учебных заданий, перенесенных из задачника Programming Taskbook}
% При наличии конструктора PT43Make и модулей, содержащих определения групп заданий из задачника Programming Taskbook (подчеркнем, что эти модули не требуют никакой модификации), динамическая библиотека, позволяющая сохранить все данные о каждом задании, может быть реализована очень простым образом. Ниже приводится текст такой библиотеки, содержащей все задания из базового набора по темам Begin, Integer, Boolean, If и Case.

% \centerline{\textbf{Файл libpt4\_en.lpr:}}

% \lstset{language=pascal}
% \begin{lstlisting}
% library libpt4_en;

% {$MODE Delphi}
    
% uses upt4utb_en;
    
% procedure initgroup(name: PChar); stdcall;
% begin
%     upt4utb_en.InitGroup(name);
% end;
    
% procedure inittask(num, test: Integer); stdcall;
% begin
%     upt4utb_en.InitTask(num, test);
% end;
    
% exports initgroup, inittask;
    
% begin
% end.     
% \end{lstlisting}

% Основной модуль библиотеки — \textbf{файл upt4utb\_en.pas:}

% \lstset{language=pascal}
% \begin{lstlisting}
% unit upt4utb_en;

% {$MODE Delphi}

% interface

% procedure InitGroup(name: string);
% procedure InitTask(num, test: Integer);

% implementation

% uses SysUtils, PT43Make, SBeg95C4, SIfc60C4;

% procedure InitGroup(name: string);

% begin
%     name := Uppercase(name);
%   if name = 'BEGIN' then
%     SetGroupData('Begin', 'Input-output and assignment', 'M. E. Abramyan, 2007, 2012', 40)
%   else if name = 'INTEGER' then
%     SetGroupData('Integer', 'Integers', 'M. E. Abramyan, 2007, 2012', 30)
%   else if name = 'BOOLEAN' then
%     SetGroupData('Boolean', 'Logical expressions', 'M. E. Abramyan, 2007, 2012', 40)
%   else if name = 'IF' then
%     SetGroupData('If', 'Conditional statement', 'M. E. Abramyan, 2007, 2012', 30)
%   else if name = 'CASE' then
%     SetGroupData('Case', 'Selection statement', 'M. E. Abramyan, 2007, 2012', 20);

% end;

% procedure InitTask(num, test: Integer);
% var name: string;
% begin
%   name := SetTaskData(num, test);
%   if name= 'BEGIN' then
%   case Num of
%      1: SBeg95Cn1('', 'subtask(1)');
%      2: SBeg95Cn1('', 'subtask(2)');
%      3: SBeg95Cn2('', '');
%      4: SBeg95Cn3('', '');
%      5: SBeg95Cn4('', '');
%      6: SBeg95Cn5('', '');
%      7: SBeg95Cn6('', '');
%      8: SBeg95Cn7('', 'subtask(1)');
%      9: SBeg95Cn7('', 'subtask(2)');
%     10: SBeg95Cn8('', '');
%     11: SBeg95Cn9('', '');
%     12: SBeg95Cn10('', '');
%     13: SBeg95Cn11('', '');
%     14: SBeg95Cn12('', 'subtask(1)');
%     15: SBeg95Cn12('', 'subtask(2)');
%     16: SBeg95Cn13('', '');
%     17: SBeg95Cn14('', '');
%     18: SBeg95Cn15('', '');
%     19: SBeg95Cn16('', '');
%     20: SBeg95Cn17('', '');
%     21: SBeg95Cn18('', '');
%     22: SBeg95Cn19('', '');
%     23: SBeg95Cn20('', 'subtask(1)');
%     24: SBeg95Cn20('', 'subtask(2)');
%     25: SBeg95Cn21('', 'subtask(1)');
%     26: SBeg95Cn21('', 'subtask(2)');
%     27: SBeg95Cn22('', '');
%     28: SBeg95Cn23('', '');
%     29: SBeg95Cn24('', 'subtask(1)');
%     30: SBeg95Cn24('', 'subtask(2)');
%     31: SBeg95Cn25('', 'subtask(1)');
%     32: SBeg95Cn25('', 'subtask(2)');
%     33: SBeg95Cn26('', 'subtask(1)');
%     34: SBeg95Cn26('', 'subtask(2)');
%     35: SBeg95Cn27('', '');
%     36: SBeg95Cn28('', 'subtask(1)');
%     37: SBeg95Cn28('', 'subtask(2)');
%     38: SBeg95Cn29('', '');
%     39: SBeg95Cn30('', '');
%     40: SBeg95Cn31('', '');
%   end
%   else if name = 'INTEGER' then
%     case Num of
%      1: SBeg95Cn37('', 'subtask(1)'+'');
%      2: SBeg95Cn37('', 'subtask(2)'+'');
%      3: SBeg95Cn38('', '');
%      4: SBeg95Cn39('', 'subtask(1)'+'');
%      5: SBeg95Cn39('', 'subtask(2)'+'');
%      6: SBeg95Cn40('', '');
%      7: SBeg95Cn41('', '');
%      8: SBeg95Cn42('', '');
%      9: SBeg95Cn43('', '');
%     10: SBeg95Cn44('', '');
%     11: SBeg95Cn45('', '');
%     12: SBeg95Cn46('', '');
%     13: SBeg95Cn47('', 'subtask(1)'+'');
%     14: SBeg95Cn47('', 'subtask(2)'+'');
%     15: SBeg95Cn48('', 'subtask(1)'+'');
%     16: SBeg95Cn48('', 'subtask(2)'+'');
%     17: SBeg95Cn49('', 'subtask(1)'+'');
%     18: SBeg95Cn49('', 'subtask(2)'+'');
%     19: SBeg95Cn50('', '');
%     20: SBeg95Cn51('', '');
%     21: SBeg95Cn52('', 'subtask(1)'+'');
%     22: SBeg95Cn52('', 'subtask(2)'+'');
%     23: SBeg95Cn52('', 'subtask(3)'+'');
%     24: SBeg95Cn53('', '');
%     25: SBeg95Cn54('', '');
%     26: SBeg95Cn55('', '');
%     27: SBeg95Cn56('', '');
%     28: SBeg95Cn57('', '');
%     29: SBeg95Cn58('', '');
%     30: SBeg95Cn59('', '');
%   end
%   else if name = 'BOOLEAN' then
%     case Num of
%        1: SBeg95Cn61('', '');
%        2: SBeg95Cn62('', 'subtask(1)'+'');
%        3: SBeg95Cn62('', 'subtask(2)'+'');
%        4: SBeg95Cn63('', 'subtask(1)'+'');
%        5: SBeg95Cn63('', 'subtask(2)'+'');
%        6: SBeg95Cn64('', '');
%        7: SBeg95Cn65('', '');
%        8: SBeg95Cn66('', '');
%        9: SBeg95Cn67('', '');
%       10: SBeg95Cn68('', '');
%       11: SBeg95Cn69('', '');
%       12: SBeg95Cn70('', '');
%       13: SBeg95Cn71('', '');
%       14: SBeg95Cn72('', '');
%       15: SBeg95Cn73('', '');
%       16: SBeg95Cn74('', 'subtask(1)'+'');
%       17: SBeg95Cn74('', 'subtask(2)'+'');
%       18: SBeg95Cn75('', 'subtask(1)'+'');
%       19: SBeg95Cn75('', 'subtask(2)'+'');
%       20: SBeg95Cn76('', '');
%       21: SBeg95Cn77('', '');
%       22: SBeg95Cn78('', '');
%       23: SBeg95Cn79('', '');
%       24: SBeg95Cn80('', '');
%       25: SBeg95Cn81('', 'subtask(1)'+'');
%       26: SBeg95Cn81('', 'subtask(2)'+'');
%       27: SBeg95Cn82('', 'subtask(1)'+'');
%       28: SBeg95Cn82('', 'subtask(2)'+'');
%       29: SBeg95Cn83('', '');
%       30: SBeg95Cn84('', '');
%       31: SBeg95Cn85('', '');
%       32: SBeg95Cn86('', '');
%       33: SBeg95Cn87('', '');
%       34: SBeg95Cn88('', '');
%       35: SBeg95Cn89('', '');
%       36: SBeg95Cn90('', '');
%       37: SBeg95Cn91('', '');
%       38: SBeg95Cn92('', '');
%       39: SBeg95Cn93('', '');
%       40: SBeg95Cn94('', '');
%     end
%   else if name = 'IF' then
%   case Num of
%      1: SIfc60Cn1('', '');
%      2: SIfc60Cn2('', '');
%      3: SIfc60Cn3('', '');
%      4: SIfc60Cn4('', '');
%      5: SIfc60Cn5('', '');
%      6: SIfc60Cn6('', '');
%      7: SIfc60Cn7('', '');
%      8: SIfc60Cn8('', '');
%      9: SIfc60Cn9('', '');
%     10: SIfc60Cn10('', '');
%     11: SIfc60Cn11('', '');
%     12: SIfc60Cn12('', '');
%     13: SIfc60Cn13('', '');
%     14: SIfc60Cn14('', '');
%     15: SIfc60Cn15('', '');
%     16: SIfc60Cn16('', '');
%     17: SIfc60Cn17('', '');
%     18: SIfc60Cn18('', '');
%     19: SIfc60Cn19('', '');
%     20: SIfc60Cn20('', '');
%     21: SIfc60Cn21('', '');
%     22: SIfc60Cn22('', '');
%     23: SIfc60Cn23('', '');
%     24: SIfc60Cn24('', '');
%     25: SIfc60Cn25('', '');
%     26: SIfc60Cn26('', '');
%     27: SIfc60Cn27('', '');
%     28: SIfc60Cn28('', '');
%     29: SIfc60Cn29('', '');
%     30: SIfc60Cn30('', '');
%   end
%   else if name = 'CASE' then
%   case Num of
%      1: SIfc60Cn32('', '');
%      2: SIfc60Cn33('', '');
%      3: SIfc60Cn34('', '');
%      4: SIfc60Cn35('', '');
%      5: SIfc60Cn36('', '');
%      6: SIfc60Cn37('', '');
%      7: SIfc60Cn38('', '');
%      8: SIfc60Cn39('', '');
%      9: SIfc60Cn40('', '');
%     10: SIfc60Cn41('', '');
%     11: SIfc60Cn42('', '');
%     12: SIfc60Cn43('', '');
%     13: SIfc60Cn44('', '');
%     14: SIfc60Cn45('', '');
%     15: SIfc60Cn46('', '');
%     16: SIfc60Cn47('', '');
%     17: SIfc60Cn48('', '');
%     18: SIfc60Cn49('', '');
%     19: SIfc60Cn50('', '');
%     20: SIfc60Cn51('', '');
%   end;

% end;

% begin
% end.
% \end{lstlisting}

% Следует заметить, что фрагменты с операторами case тоже берутся без каких-либо модификаций из соответствующих модулей исходного задачника Programming Taskbook.
% Библиотека экспортирует всего две функции: initgroup(name: PChar), которая определяет имя группы заданий, и inittask(num, test: Integer), которая инициализирует задание с указанным номером (также задается номер тестового испытания, поскольку для конкретных номеров тестов могут быть предусмотрены особые наборы исходных данных). Именно функция inittask обеспечивает генерацию на диске файла \$\$pt4dat\$\$.dat с полной информацией о выбранном задании.


\section{Дополнительный модуль ut1.cpp, подключаемый к учебной программе}

\subsection{Схема использования данных, связанных с заданием, в учебной программе: дополнительный модуль ut1.cpp}
Таким образом, при использовании описанной схемы выполнения заданий, импортированных из задачника Programming Taskbook, задачник Unix Taskbook должен выполнять следующую последовательность действий:

На следующем этапе реализации проекта переноса базового набора заданий задачника Programming Taskbook в задачник Unix Taskbook было необходимо разработать схему использования данных, подготовленных при инициализации задания, в учебной программе, выполняющей это задание. Задачник Programming Taskbook содержит встроенные средства для ввода исходных данных и вывода результатов; эти средства импортируются из ядра задачника и позволяют учебной программе получать исходные данные и передавать результаты задачнику на проверку. 
В задачнике Unix Taskbook подобных встроенных средств нет; это, в частности, означает, что при его использовании нет необходимости в подключении особых модулей к учебной программе. Например, можно реализовать группу заданий, в которой все исходные данные передаются в виде параметров командной строки, а результаты сохраняются в некотором файле. В этом случае учебная программа может разрабатываться как независимое приложение, которое можно запускать отдельно от задачника Unix Taskbook, явно указывая необходимые параметры командной строки и анализируя файлы, полученные в результате выполнения программы. Однако при ее запуске под управлением задачника появляются дополнительные возможности: задачник сам формирует набор параметров и сам проверяет правильность полученных файлов. Такая схема была использована при разработке групп заданий, связанных с различными темами курса по операционным системам.
Аналогичную схему можно реализовать и для заданий, перенесенных из задачника Programming Taskbook. Однако при этом всё же требуется подключать к учебной программе дополнительный набор функций, которые позволяют при запуске программы под управлением задачника получать исходные, сгенерированные задачником, и передавать полученные результаты ему на проверку. Если же программа запущена как отдельное приложение, то эти же функции позволяют ввести исходные данные с клавиатуры и вывести полученные результаты на экран. В набор дополнительных функций включены также функции отладочного вывода, которые упрощают вывод отладочных данных на экран как при запуске учебной программы под управлением задачника, так и при ее независимом запуске. Заметим, что данный набор функций оказывается особенно удобным для учебных программ, разрабатываемых на языке C, так как стандартные функции ввода-вывода в этом языке являются достаточно сложными.
Признаком того, что учебная программа запущена под управлением задачника Unix Taskbook, является наличие в рабочем каталоге особого файла ut1inf.dat с основными характеристиками задания. При его наличии функции ввода получают информацию из еще одного дополнительного файла (одного или нескольких — в случае выполнения задания по параллельному программированию), а функции вывода и отладочного вывода выводят результаты не на экран, а в специальные файлы, которые в дальнейшем анализируются задачником. Кроме того, в особый файл также записывается информация об ошибках, которые можно обнаружить непосредственно при работе учебной программы (это ошибки, связанные с операциями ввода: ввод недостаточного или избыточного числа исходных данных или попытка ввода данных неверного типа). Заметим, что при обнаружении какой-либо ошибки учебная программа немедленно завершается. Окончательная проверка правильности решения выполняется задачником на заключительном этапе, когда анализируются полученные результаты, проверяется их количество, тип и соответствие контрольным значениям.
В текущей реализации дополнительный файл ut1.h включает набор функций, позволяющий выполнять ввод, вывод и отладочный вывод на языках C и C++:

\lstset{language=c++}
\begin{lstlisting}
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
    
void ShowB(bool b);
void ShowN(int n);
void ShowD(double d);
void ShowC(char c);
void ShowS(const char *s);
    
void Show(const char *cmt);
void ShowW(const wchar_t *cmt);
    
void ShowLineB(bool b);
void ShowLineN(int n);
void ShowLineD(double d);
void ShowLineC(char c);
void ShowLineS(const char *s);
    
void ShowLine(const char *cmt);
void ShowLineW(const wchar_t *cmt);
    
void PutB(bool a);
void PutN(int a);
void PutD(double a);
void PutC(char a);
void PutS(const char *a);
    
void GetB(bool *a);
void GetN(int *a);
void GetD(double *a);
void GetC(char *a);
void GetS(char *a);
    
void SetPrecision(int n);
void SetWidth(int n);
\end{lstlisting}

Он соответствует набору, реализованному в задачнике Programming Taskbook версии 4.23 для языка C. На базе этого набора функций несложно реализовать более гибкий набор средств ввода-вывода для языка С++ (подобно тому, как это сделано в задачнике Programming Taskbook). Более того, поскольку исходный набор данных и другая исходная информация считывается из обычных текстовых файлов, а результаты и другие данные, связанные с выполнением задания (сообщения об ошибках и отладочные данные), также записываются в текстовые файлы, несложно разработать аналогичный набор функций и для других языков.
В качестве иллюстрации того, как реализованы функции, описанные в файле ut1.h, приведем текст вспомогательной функции put\_, используемой во всех функциях вывода, и пример ее использования в функции для вывода целых чисел PutN:

\lstset{language=c++}
\begin{lstlisting}
void put_(char id, double n, char c, const char *s)
{
  if (psize == -1)
    init_();
  if (psize == 0)
  {
    switch (id)
    {
    case 'b':
      ShowB((int)n);
      break;
    case 'i':
      ShowN((int)n);
      break;
    case 'r':
      ShowD(n);
      break;
    case 'c':
      ShowC(c);
      break;
    case 's':
      ShowS(s);
      break;
    }
  }
  else
  {
    FILE *f = fopen(outdat, "a");
    fprintf(f, "%c\n", id);
    switch (id)
    {
    case 'b':
      fprintf(f, "%d\n", (int)n);
      break;
    case 'i':
      fprintf(f, "%d\n", (int)n);
      break;
    case 'r':
      fprintf(f, "%0.14e\n", n);
      break;
    case 'c':
      fprintf(f, "%c\n", c);
      break;
    case 's':
      fprintf(f, "%s\n", s);
      break;
    }
    fclose(f);
  }
}

void PutN(int a)
{
  put_('i', a, ' ', 0);
}

\end{lstlisting}

\subsection{Порядок действий задачника Unix Taskbook при выполнении заданий, импортированных из задачника Programming Taskbook}
\begin{enumerate}
    \item определение группы задач и номера задачи в этой группе; эта информация передается в качестве параметра командной строки при запуске задачника Unix Taskbook;
    \item компиляция учебной программы (если в ходе компиляции были обнаружены ошибки, то вывод соответствующего сообщения и немедленное завершение работы);
    \item загрузка динамической библиотеки, связанной с указанной группой заданий и передача ей управления;
    \item вызов из данной динамической библиотеки функций initgroup и inittask базовой динамической библиотеки, перенесенной из задачника Programming Taskbook (см. выше ее описание); в результате этого вызова на диске будет создан файл \$\$pt4dat\$\$.dat; анализ этого файла; в частности, определение количество требуемых тестовых запусков;
    \item считывание данных из файла \$\$pt4dat\$\$.dat и генерация на их основе дополнительных файлов, которые будут использоваться при выполнении учебной программы; после этого файл \$\$pt4dat\$\$.dat желательно удалить;
    \item запуск откомпилированной учебной программы и ожидание ее завершения;
    \item анализ файлов, созданных при работе учебной программы, проверка правильности решения и отображение всей информации, связанной с решением, на экране;
    \item при успешном прохождении текущего теста повторный вызов функции inittask для того же задания с целью генерации очередного набора тестовых данных и повторное выполнение шагов 5–8, пока не будут успешно пройдены все требуемые тесты или пока не будет обнаружена ошибка в решении.
\end{enumerate}

\newpage